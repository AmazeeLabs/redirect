<?php

/**
 * @file
 * The redirect module.
 */

/**
 * @defgroup redirect_api Redirection API
 * @{
 * Functions related to URL redirects.
 *
 * @} End of "defgroup redirect_api".
 */
use Drupal\Component\Utility\Crypt;
use Drupal\Component\Utility\String;
use Drupal\Component\Utility\UrlHelper;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Field\FieldItemList;
use Drupal\Core\Language\Language;
use Drupal\redirect\Entity\Redirect;
use Drupal\user\UserInterface;

/**
 * Modules should return this value from hook_redirect_access() to allow access
 * to a redirect.
 */
define('REDIRECT_ACCESS_ALLOW', 'allow');

/**
 * Modules should return this value from hook_redirect_access() to deny access
 * to a redirect.
 */
define('REDIRECT_ACCESS_DENY', 'deny');

/**
 * Modules should return this value from hook_redirect_access() to not affect
 * redirect access.
 */
define('REDIRECT_ACCESS_IGNORE', NULL);


/**
 * Implements hook_hook_info().
 */
function redirect_hook_info() {
  $hooks = array(
    'redirect_load',
    'redirect_load_by_source_alter',
    'redirect_access',
    'redirect_prepare',
    'redirect_validate',
    'redirect_presave',
    'redirect_insert',
    'redirect_update',
    'redirect_delete',
    'redirect_alter',
  );

  return array_fill_keys($hooks, array('group' => 'redirect'));
}

/**
 * Implements hook_permission().
 */
function redirect_permission() {
  $permissions['administer redirects'] = array(
    'title' => t('Administer URL redirections'),
  );
  return $permissions;
}

/**
 * Implements hook_help().
 */
function redirect_help($path, $arg) {
  $output = '';
  switch ($path) {
    case 'admin/config/search/redirect/404':
      $output = '<p>' . t('This page lists all paths that have resulted in 404 errors and do not yet have any redirects assigned to them.') . '</p>';
      break;
    case 'admin/reports/page-not-found':
      break;
  }
  return $output;
}

/**
 * Implements hook_cron().
 */
function redirect_cron() {
  // Purge inactive self-managed redirects from the database.
  redirect_purge_inactive_redirects();
}

/**
 * Implements hook_entity_delete().
 *
 * Will delete redirects based on the entity URL.
 */
function redirect_entity_delete(EntityInterface $entity, $entity_type) {
  if (redirect_entity_has_path_field($entity)) {
    redirect_delete_by_path($entity->url());
  }
}

/**
 * Implements hook_path_update().
 *
 * Will create redirect from the old path alias to the new one.
 */
function redirect_path_update(array $path) {
  if (!\Drupal::config('redirect.settings')->get('auto_redirect')) {
    return;
  }
  $unchanged_path = redirect_path_get_unchanged();
  if (!empty($unchanged_path) && $unchanged_path['pid'] == $path['pid'] && $unchanged_path['alias'] != $path['alias']) {
    if (!redirect_repository()->findMatchingRedirect($unchanged_path['alias'], array(), $unchanged_path['langcode'])) {
      $redirect = redirect_create();
      $redirect->setSource($unchanged_path['alias']);
      $redirect->setRedirect($path['alias']);
      $redirect->setLanguage($unchanged_path['langcode']);
      $redirect->setStatusCode(\Drupal::config('redirect.settings')->get('default_status_code'));
      $redirect->save();
    }
  }
}

/**
 * Implements hook_path_delete().
 */
function redirect_path_delete($path) {
  if (!\Drupal::config('redirect.settings')->get('auto_redirect')) {
    return;
  }
  elseif (isset($path['redirect']) && !$path['redirect']) {
    return;
  }
  elseif (empty($path)) {
    // @todo Remove this condition and allow $path to use an array type hint
    // when http://drupal.org/node/1025904 is fixed.
    return;
  }

  // Redirect from a deleted alias to the system path.
  //if (!redirect_load_by_source($path['alias'], $path['language'])) {
  //  $redirect = new stdClass();
  //  redirect_create($redirect);
  //  $redirect->source = $path['alias'];
  //  $redirect->redirect = $path['source'];
  //  $redirect->language = $path['language'];
  //  redirect_save($redirect);
  //}
}

/**
 * Implements hook_page_build().
 *
 * Adds an action on 404 pages to create a redirect.
 */
function redirect_page_build(&$page) {
  if (redirect_is_current_page_404() && \Drupal::currentUser()->hasPermission('administer redirects')) {
    if (!isset($page['content']['system_main']['actions'])) {
      $page['content']['system_main']['actions'] = array(
        '#theme' => 'links',
        '#links' => array(),
        '#attributes' => array('class' => array('action-links')),
        '#weight' => -100,
      );
    }
    // We cannot simply use current_path() because if a 404 path is set, then
    // that value overrides whatever is in $_GET['q']. The
    // drupal_deliver_html_page() function thankfully puts the original current
    // path into $_GET['destination'].
    $destination = drupal_get_destination();
    $page['content']['system_main']['actions']['#links']['add_redirect'] = array(
      'title' => t('Add URL redirect from this page to another location'),
      'href' => 'admin/config/search/redirect/add',
      'query' => array('source' => $destination['destination']) + drupal_get_destination(),
    );
  }
}

/**
 * Implements hook_entity_presave().
 *
 * Adds unchanged path info in case we find the path field.
 */
function redirect_entity_presave(EntityInterface $entity) {
  if (!$entity->isNew() && redirect_entity_has_path_field($entity)) {
    redirect_path_set_unchanged(\Drupal::service('path.alias_storage')->load(array('pid' => $entity->path->pid)));
  }
}

/**
 * Checks if the entity has path field.
 *
 * @param EntityInterface $entity
 *   The entity to check.
 *
 * @return bool
 *   TRUE if the entity has the path field.
 */
function redirect_entity_has_path_field(EntityInterface $entity) {
  if (isset($entity->path) && $entity->path instanceof FieldItemList) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Adds support for creating redirects if an URL alias is changed.
 */
function redirect_form_path_admin_edit_alter(&$form, &$form_state) {
  if (!empty($form['pid']['#value'])) {
    redirect_path_set_unchanged(\Drupal::service('path.alias_storage')->load(array('pid' => $form['pid']['#value'])));
  }
}

/**
 * Stores the unchanged path.
 *
 * @param string $unchanged_path
 *   The unchanged path.
 */
function redirect_path_set_unchanged($unchanged_path) {
  // Using a static cache seems more appropriate than states. However it did not
  // work for the node form, where the form alter hook is not invoked during the
  // submit action.
  //$path = &drupal_static('redirect_unchanged_path');
  //$path = $unchanged_path;
  \Drupal::state()->set('redirect_unchanged_path', $unchanged_path);
}

/**
 * Gets the original path data if any set.
 *
 * @return array
 *   The path data.
 */
function redirect_path_get_unchanged() {
  //return drupal_static('redirect_unchanged_path');
  $unchanged_path = \Drupal::state()->get('redirect_unchanged_path');
  \Drupal::state()->set('redirect_unchanged_path', NULL);
  return $unchanged_path;
}

/**
 * Gets the redirect repository service.
 *
 * @return \Drupal\redirect\RedirectRepository
 *   The repository service.
 */
function redirect_repository() {
  return \Drupal::service('redirect.repository');
}

/**
 * Determine whether the current user may perform the given operation on the
 * specified redirect.
 *
 * @param string $op
 *   The operation to be performed on the redirect. Possible values are:
 *   - "create"
 *   - "update"
 *   - "delete"
 * @param object $redirect
 *   The redirect object on which the operation is to be performed, or redirect
 *   type (e.g. 'feedburner') for the "create" operation.
 * @param UserInterface $account
 *   Optional, a user object representing the user for whom the operation is to
 *   be performed. Determines access for a user other than the current user.
 *
 * @return bool
 *   TRUE if the operation may be performed, FALSE otherwise.
 */
function redirect_access($op, $redirect, UserInterface $account = NULL) {
  global $user;

  $rights = &drupal_static(__FUNCTION__, array());

  if (!$redirect || !in_array($op, array('create', 'update', 'delete'), TRUE)) {
    // If there was no redirect to check against, or the $op was not one of the
    // supported ones, we return access denied.
    return FALSE;
  }
  // If no user object is supplied, the access check is for the current user.
  if (empty($account)) {
    $account = $user;
  }

  $cid = isset($redirect->rid) ? $redirect->rid : $redirect;

  // Return cached value if access already checked for this redirect, user and op.
  if (isset($rights[$account->id()][$cid][$op])) {
    return $rights[$account->id()][$cid][$op];
  }

  // Administrators can access all redirects.
  if ($account->hasPermission('administer redirects')) {
    $rights[$account->id()][$cid][$op] = TRUE;
    return TRUE;
  }

  // We grant access to the redirect if both of the following conditions are met:
  // - No modules say to deny access.
  // - At least one module says to grant access.
  $access = \Drupal::moduleHandler()->invokeAll('redirect_access', array('op' => $op, 'redirect' => $redirect, 'account' => $account));
  if (in_array(REDIRECT_ACCESS_DENY, $access, TRUE)) {
    $rights[$account->id()][$cid][$op] = FALSE;
    return FALSE;
  }
  elseif (in_array(REDIRECT_ACCESS_ALLOW, $access, TRUE)) {
    $rights[$account->id()][$cid][$op] = TRUE;
    return TRUE;
  }

  return FALSE;
}

/**
 * Creates a redirect entity object.
 *
 * @param array $values
 *   Initial values to be set for the entity object.
 *
 * @return \Drupal\redirect\Entity\Redirect
 *   The created redirect entity object.
 */
function redirect_create($values = array()) {
  return entity_create('redirect', $values);
}

/**
 * Implements hook_redirect_insert().
 */
function redirect_redirect_insert($redirect) {
  redirect_page_cache_clear($redirect);
}

/**
 * Implements hook_redirect_update().
 */
function redirect_redirect_update($redirect) {
  redirect_page_cache_clear($redirect);

  // Clear the page cache for the original redirect as well.
  // @todo - this is causing an infinite loop.
//  if (!empty($redirect->original) && $redirect->original->source != $redirect->source) {
//    redirect_page_cache_clear($redirect->original);
//  }
}

/**
 * Implements hook_redirect_delete().
 */
function redirect_redirect_delete($redirect) {
  redirect_page_cache_clear($redirect);
}

/**
 * Delete any redirects associated with a path or any of its sub-paths.
 *
 * Given a source like 'node/1' this function will delete any redirects that
 * have that specific source or any sources that match 'node/1/%'.
 *
 * @param $path
 *   An string with an internal Drupal path.
 *
 * @ingroup redirect_api
 */
function redirect_delete_by_path($path) {
  $path = ltrim($path, '/');
  $query = db_select('redirect');
  $query->addField('redirect', 'rid');
  $query_or = db_or();
  $query_or->condition('redirect_source__url', db_like($path), 'LIKE');
  $query_or->condition('redirect_source__url', db_like($path . '/') . '%', 'LIKE');
  $query_or->condition('redirect_redirect__url', db_like($path), 'LIKE');
  $query_or->condition('redirect_redirect__url', db_like($path . '/') . '%', 'LIKE');

  $query->condition($query_or);
  $rids = $query->execute()->fetchCol();

  if ($rids) {
    foreach (redirect_repository()->loadMultiple($rids) as $redirect) {
      $redirect->delete();
    }
  }
}

/**
 * Purge inactive redirects from the database.
 *
 * @param $types
 *   An array of redirect types to remove. Default is only the self-managed
 *   'redirect'. If not provided all redirect types will be eligible for
 *   removal.
 * @param $interval
 *   The number of seconds to subtract from the current time and used to
 *   find the inactive redirects.
 *
 * @return
 *   An array of redirect IDs that were deleted or FALSE if none were.
 */
function redirect_purge_inactive_redirects(array $types = array('redirect'), $interval = NULL) {
  if (!isset($interval)) {
    $interval = \Drupal::config('redirect.settings')->get('purge_inactive');
  }

  if (!$interval || !\Drupal::config('redirect.settings')->get('page_cache') || !\Drupal::config('system.performance')->get('cache.page.invoke_hooks')) {
    // If serving redirects from the page cache is enabled and hooks are not
    // executed during page caching, then we cannot track when a redirect is
    // used. Therefore, we cannot remove unused redirects.
    return FALSE;
  }

  $query = db_select('redirect');
  $query->addField('redirect', 'rid');
  if (!empty($types)) {
    $query->condition('type', $types);
  }
  $query->condition('access', REQUEST_TIME - $interval, '<');
  $query->addTag('redirect_purge');
  $rids = $query->execute()->fetchCol();

  if (count($rids)) {
    foreach (redirect_repository()->loadMultiple($rids) as $redirect) {
      $redirect->delete();
    }
    watchdog('redirect', String::format(count($rids), 'Removed 1 inactive redirect from the database.', 'Removed @count inactive redirects from the database.'));
    return $rids;
  }
}

/**
 * Clear a page from the page cache.
 */
function redirect_page_cache_clear($redirect = NULL) {
  if (!\Drupal::config('redirect.settings')->get('page_cache')) {
    return;
  }

  if (isset($redirect)) {
    $path = url($redirect->source, array('absolute' => TRUE));
    // Use a wildcard to catch paths with query strings.
    \Drupal::cache('cache_page')->delete($path);
  }
  else {
    // Clear the entire page cache.
    \Drupal::cache('cache_page')->deleteAll();
  }
}

/**
 * Compare tha all values and associations in one array match another array.
 *
 * We cannot use array_diff_assoc() here because we need to be recursive.
 *
 * @param $match
 *   The array that has the values.
 * @param $haystack
 *   The array that will be searched for values.
 * @return
 *   TRUE if all the elements of $match were found in $haystack, or FALSE
 *   otherwise.
 */
function redirect_compare_array_recursive($match, $haystack) {
  foreach ($match as $key => $value) {
    if (!array_key_exists($key, $haystack)) {
      return FALSE;
    }
    elseif (is_array($value)) {
      if (!is_array($haystack[$key])) {
        return FALSE;
      }
      elseif (!redirect_compare_array_recursive($value, $haystack[$key])) {
        return FALSE;
      }
    }
    elseif ($value != $haystack[$key]) {
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Sort an array recusively.
 *
 * @param $array
 *   The array to sort, by reference.
 * @param $callback
 *   The sorting callback to use (e.g. 'sort', 'ksort', 'asort').
 *
 * @return
 *   TRUE on success or FALSE on failure.
 */
function redirect_sort_recursive(&$array, $callback = 'sort') {
  $result = $callback($array);
  foreach ($array as $key => $value) {
    if (is_array($value)) {
      $result &= redirect_sort_recursive($array[$key], $callback);
    }
  }
  return $result;
}

/**
 * Build the URL of a redirect for display purposes only.
 */
function redirect_url($path, array $options = array(), $clean_url = NULL) {
  // @todo - deal with removal of clean_url config. See
  //    https://drupal.org/node/1659580
  if (!isset($clean_url)) {
    //$clean_url = variable_get('clean_url', 0);
  }

  if ($path == '') {
    $path = '<front>';
  }

  if (!isset($options['alter']) || !empty($options['alter'])) {
    \Drupal::moduleHandler()->alter('redirect_url', $path, $options);
  }

  // The base_url might be rewritten from the language rewrite in domain mode.
  if (!isset($options['base_url'])) {
    // @todo - is this correct? See https://drupal.org/node/1798832.
    if (isset($options['https']) && settings()->get('mixed_mode_sessions', FALSE)) {
      if ($options['https'] === TRUE) {
        $options['base_url'] = $GLOBALS['base_secure_url'];
        $options['absolute'] = TRUE;
      }
      elseif ($options['https'] === FALSE) {
        $options['base_url'] = $GLOBALS['base_insecure_url'];
        $options['absolute'] = TRUE;
      }
    }
    else {
      $options['base_url'] = $GLOBALS['base_url'];
    }
  }

  if (empty($options['absolute']) || url_is_external($path)) {
    $url = $path;
  }
  else {
    $url = $options['base_url'] . base_path() . $path;
  }

  if (isset($options['query'])) {
    $url .= $clean_url ? '?' : '&';
    $url .= UrlHelper::buildQuery($options['query']);
  }
  if (isset($options['fragment'])) {
    $url .= '#' . $options['fragment'];
  }

  return $url;
}

function redirect_parse_url($url) {
  $original_url = $url;
  $url = trim($url, " \t\n\r\0\x0B\/");
  $parsed = parse_url($url);

  if (isset($parsed['fragment'])) {
    $url = substr($url, 0, -strlen($parsed['fragment']));
    $url = trim($url, '#');
  }
  if (isset($parsed['query'])) {
    $url = substr($url, 0, -strlen($parsed['query']));
    $url = trim($url, '?&');
    $parsed_query = array();
    parse_str($parsed['query'], $parsed_query);
    $parsed['query'] = $parsed_query;
  }

  // Convert absolute to relative.
  if (isset($parsed['scheme']) && isset($parsed['host'])) {
    $base_secure_url = rtrim($GLOBALS['base_secure_url'] . base_path(), '/');
    $base_insecure_url = rtrim($GLOBALS['base_insecure_url'] . base_path(), '/');
    if (strpos($url, $base_secure_url) === 0) {
      $url = str_replace($base_secure_url, '', $url);
      $parsed['https'] = TRUE;
    }
    elseif (strpos($url, $base_insecure_url) === 0) {
      $url = str_replace($base_insecure_url, '', $url);
    }
  }

  $url = trim($url, '/');

  // Convert to frontpage paths.
  if ($url == '<front>') {
    $url = '';
  }

  //$parsed['url'] = http_build_query($url, HTTP_URL_STRIP_QUERY | HTTP_URL_STRIP_FRAGMENT);
  $parsed['url'] = $url;

  // Allow modules to alter the parsed URL.
  drupal_alter('redirect_parse_url', $parsed, $original_url);

  return $parsed;
}

function redirect_status_code_options($code = NULL) {
  $codes = array(
    300 => t('300 Multiple Choices'),
    301 => t('301 Moved Permanently'),
    302 => t('302 Found'),
    303 => t('303 See Other'),
    304 => t('304 Not Modified'),
    305 => t('305 Use Proxy'),
    307 => t('307 Temporary Redirect'),
  );
  return isset($codes[$code]) ? $codes[$code] : $codes;
}

/**
 * Returns if the current page request is a page not found (404 status error).
 *
 * Why the fuck do we have to do this? Why is there not an easier way???
 *
 * @return
 *   TRUE if the current page is a 404, or FALSE otherwise.
 */
function redirect_is_current_page_404() {
  return drupal_get_http_header('Status') == '404 Not Found';
}

/**
 * uasort callback; Compare redirects based on language neutrality and rids.
 */
function _redirect_uasort($a, $b) {
  $a_weight = isset($a->weight) ? $a->weight : 0;
  $b_weight = isset($b->weight) ? $b->weight : 0;
  if ($a_weight != $b_weight) {
    // First sort by weight (case sensitivity).
    return $a_weight > $b_weight;
  }
  elseif ($a->language != $b->language) {
    // Then sort by language specific over language neutral.
    return $a->language == Language::LANGCODE_NOT_SPECIFIED;
  }
  elseif (!empty($a->source_options['query']) != !empty($b->source_options['query'])) {
    // Then sort by redirects that do not have query strings over ones that do.
    return empty($a->source_options['query']);
  }
  else {
    // Lastly sort by the highest redirect ID.
    return $a->rid < $b->rid;
  }
}

/**
 * Implements hook_form_FORM_ID_alter() on behalf of locale.module.
 */
function locale_form_redirect_edit_form_alter(&$form, &$form_state) {
  $form['language'] = array(
    '#type' => 'select',
    '#title' => t('Language'),
    '#options' => array(Language::LANGCODE_NOT_SPECIFIED => t('All languages')) + \Drupal::languageManager()->getLanguages(),
    '#default_value' => $form['language']['#value'],
    '#description' => t('A redirect set for a specific language will always be used when requesting this page in that language, and takes precedence over redirects set for <em>All languages</em>.'),
  );
}

/**
 * Fetch an array of redirect bulk operations.
 *
 * @see hook_redirect_operations()
 * @see hook_redirect_operations_alter()
 */
function redirect_get_redirect_operations() {
  $operations = &drupal_static(__FUNCTION__);

  if (!isset($operations)) {
    $operations = \Drupal::moduleHandler()->invokeAll('redirect_operations');
    \Drupal::moduleHandler()->alter('redirect_operations', $operations);
  }

  return $operations;
}

/**
 * Implements hook_redirect_operations().
 */
function redirect_redirect_operations() {
  $operations['delete'] = array(
    'action' => t('Delete'),
    'action_past' => t('Deleted'),
    'callback' => 'redirect_delete_multiple',
    'confirm' => TRUE,
  );
  return $operations;
}

/**
 * Ajax callback for the redirect link widget.
 */
function redirect_source_link_get_status_messages($form, &$form_state) {
  return $form['redirect_source']['widget'][0]['status_box'];
}
